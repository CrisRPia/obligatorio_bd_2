/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * backend
 * OpenAPI spec version: 1.0
 */
export interface Ballot {
  electionId: string;
  ballotId: string;
  /**
   * Specify if vote type is List.
   * @nullable
   */
  listNumber?: number | null;
  /**
   * Specify if vote type is Boolean.
   * @nullable
   */
  isYes?: boolean | null;
}

export interface Ballots {
  items: Ballot[];
}

export interface BaseCitizen {
  /**
   * @minLength 1
   * @pattern ^[A-Z]{3}\d+$
   */
  credencialCivica: string;
  uruguayanId: number;
}

export interface BooleanReturn {
  success: boolean;
}

export interface BooleanVote {
  yes: boolean;
  /**
   * @minLength 3
   * @maxLength 3
   */
  colorHex: string;
}

export interface BooleanVoteVoteResult {
  percentage: number;
  voteCount: number;
  vote: BooleanVote;
}

export interface Building {
  buildingId: string;
  /** @minLength 1 */
  name: string;
  /** @minLength 1 */
  address: string;
  zone: Zone;
}

export interface Candidate {
  candidateId: string;
  /** @minLength 1 */
  name: string;
  /** @minLength 1 */
  surname: string;
  position: number;
}

export interface CandidateList {
  /**
   * The ordered list of candidates on this voting list. The first candidate is the main candidate.
   * @minItems 1
   */
  candidates: Candidate[];
  party: Party;
  listNumber: number;
}

export interface CandidateListVoteResult {
  percentage: number;
  voteCount: number;
  vote: CandidateList;
}

export interface Circuit {
  circuitId: CircuitId;
  building: Building;
}

export interface CircuitId {
  circuitNumber: number;
  establishmentId: string;
}

export interface CitizenCreationResult {
  fakeCitizen: FullCitizen;
  citizenId: string;
}

export interface Department {
  /** @minLength 1 */
  name: string;
  departmentId: string;
}

export interface Election {
  type: ElectionType;
  date: string;
  allowedBallots: Ballot[];
  electionId: string;
  /** @nullable */
  departmentId?: string | null;
  result?: ElectionResult;
}

export interface ElectionListModel {
  items: Election[];
}

export interface ElectionResult {
  type: ElectionType;
  /** @nullable */
  booleanResult?: BooleanVoteVoteResult[] | null;
  /** @nullable */
  listBasedResult?: CandidateListVoteResult[] | null;
  totalVotes: number;
}

export type ElectionState = (typeof ElectionState)[keyof typeof ElectionState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ElectionState = {
  Open: "Open",
  Closed: "Closed",
} as const;

export type ElectionType = (typeof ElectionType)[keyof typeof ElectionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ElectionType = {
  Presidential: "Presidential",
  Referendum: "Referendum",
  Plebiscite: "Plebiscite",
  MunicipalElection: "MunicipalElection",
  Runoff: "Runoff",
} as const;

export interface EmbeddedJwtData {
  /** @nullable */
  username: string | null;
  userId: string;
  /** @nullable */
  tokenId: string | null;
  circuitId?: CircuitId;
  /** @nullable */
  roles: Role[] | null;
}

export interface FakeInitResult {
  createdCitizens: FullCitizen[];
  electionId: string;
  parties: Party[];
  circuits: Circuit[];
  activeCircuit: Circuit;
  tables: Table[];
  building: Building;
}

export interface FullCitizen {
  /**
   * @minLength 1
   * @pattern ^[A-Z]{3}\d+$
   */
  credencialCivica: string;
  uruguayanId: number;
  birthDate: string;
  /** @minLength 1 */
  name: string;
  /** @minLength 1 */
  surname: string;
  citizenId: string;
}

export interface FullCitizenAuthResponse {
  /** @minLength 1 */
  jwtToken: string;
  roles: Role[];
  citizenId: string;
  user: FullCitizen;
}

export interface FullCitizenOption {
  value?: FullCitizen;
}

export interface Locality {
  localityId: string;
  department: Department;
  type: LocalityType;
}

export type LocalityType = (typeof LocalityType)[keyof typeof LocalityType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocalityType = {
  City: "City",
  Town: "Town",
  Other: "Other",
} as const;

export interface LoginCredentials {
  /**
   * @minLength 1
   * @pattern ^[A-Z]{3}\d+$
   */
  credencialCivica: string;
  uruguayanId: number;
  /** @minLength 1 */
  password: string;
}

export interface Party {
  /** @minLength 1 */
  headquartersAddress: string;
  /** @minLength 1 */
  name: string;
  partyId: string;
  citizens: BaseCitizen[];
}

export type Role = (typeof Role)[keyof typeof Role];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Role = {
  Voter: "Voter",
  BoardPresident: "BoardPresident",
  BoardVocal: "BoardVocal",
  BoardSecretary: "BoardSecretary",
  Admin: "Admin",
  Police: "Police",
} as const;

export interface Table {
  president: FullCitizen;
  secretary: FullCitizen;
  vocal: FullCitizen;
}

export interface ValueTuple {
  [key: string]: unknown;
}

export interface ValueTupleAuthResponse {
  /** @minLength 1 */
  jwtToken: string;
  roles: Role[];
  citizenId: string;
  user: ValueTuple;
}

export interface Zone {
  zoneId: string;
  locality: Locality;
}

export type GetCitizenParams = {
  /**
   * @pattern ^[A-Z]{3}\d+$
   */
  credencialCivica: string;
};

export type GetDebugFakeCitizensParams = {
  startUid?: number;
  endUid?: number;
};

export type GetElectionsParams = {
  MinimumDateTime?: string;
  MaximumDateTime?: string;
  DepartmentId?: string;
  OnlyOpenOrClosed?: ElectionState;
  /**
   * Do not specify (or empty) to set to all.
   */
  RestrictToTypes?: ElectionType[];
  SearchTerm?: string;
  HasResults?: boolean;
  AvailableForUser?: string;
};

export type PostTableCitizenIdAuthorizeParams = {
  authorizeObserved?: boolean;
};

export type getAuthJWTResponse200 = {
  data: EmbeddedJwtData;
  status: 200;
};

export type getAuthJWTResponseComposite = getAuthJWTResponse200;

export type getAuthJWTResponse = getAuthJWTResponseComposite & {
  headers: Headers;
};

export const getGetAuthJWTUrl = () => {
  return `http://localhost:8080/auth/JWT`;
};

export const getAuthJWT = async (
  options?: RequestInit,
): Promise<getAuthJWTResponse> => {
  const res = await fetch(getGetAuthJWTUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getAuthJWTResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getAuthJWTResponse;
};

export type postAuthResponse200 = {
  data: FullCitizenAuthResponse;
  status: 200;
};

export type postAuthResponseComposite = postAuthResponse200;

export type postAuthResponse = postAuthResponseComposite & {
  headers: Headers;
};

export const getPostAuthUrl = () => {
  return `http://localhost:8080/auth`;
};

export const postAuth = async (
  loginCredentials: LoginCredentials,
  options?: RequestInit,
): Promise<postAuthResponse> => {
  const res = await fetch(getPostAuthUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(loginCredentials),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postAuthResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postAuthResponse;
};

export type postCitizenCitizenIdVoteResponse200 = {
  data: BooleanReturn;
  status: 200;
};

export type postCitizenCitizenIdVoteResponseComposite =
  postCitizenCitizenIdVoteResponse200;

export type postCitizenCitizenIdVoteResponse =
  postCitizenCitizenIdVoteResponseComposite & {
    headers: Headers;
  };

export const getPostCitizenCitizenIdVoteUrl = (citizenId: string) => {
  return `http://localhost:8080/citizen/${citizenId}/vote`;
};

export const postCitizenCitizenIdVote = async (
  citizenId: string,
  ballots: Ballots,
  options?: RequestInit,
): Promise<postCitizenCitizenIdVoteResponse> => {
  const res = await fetch(getPostCitizenCitizenIdVoteUrl(citizenId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(ballots),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postCitizenCitizenIdVoteResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postCitizenCitizenIdVoteResponse;
};

/**
 * @summary  (Secured - Roles: BoardPresident)
 */
export type getCitizenResponse200 = {
  data: FullCitizenOption;
  status: 200;
};

export type getCitizenResponseComposite = getCitizenResponse200;

export type getCitizenResponse = getCitizenResponseComposite & {
  headers: Headers;
};

export const getGetCitizenUrl = (params: GetCitizenParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8080/citizen?${stringifiedParams}`
    : `http://localhost:8080/citizen`;
};

export const getCitizen = async (
  params: GetCitizenParams,
  options?: RequestInit,
): Promise<getCitizenResponse> => {
  const res = await fetch(getGetCitizenUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getCitizenResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCitizenResponse;
};

export type postDebugFakeInitResponse200 = {
  data: FakeInitResult;
  status: 200;
};

export type postDebugFakeInitResponseComposite = postDebugFakeInitResponse200;

export type postDebugFakeInitResponse = postDebugFakeInitResponseComposite & {
  headers: Headers;
};

export const getPostDebugFakeInitUrl = () => {
  return `http://localhost:8080/debug/fake/init`;
};

export const postDebugFakeInit = async (
  options?: RequestInit,
): Promise<postDebugFakeInitResponse> => {
  const res = await fetch(getPostDebugFakeInitUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postDebugFakeInitResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postDebugFakeInitResponse;
};

export type getDebugFakeCitizenResponse200 = {
  data: FullCitizen;
  status: 200;
};

export type getDebugFakeCitizenResponseComposite =
  getDebugFakeCitizenResponse200;

export type getDebugFakeCitizenResponse =
  getDebugFakeCitizenResponseComposite & {
    headers: Headers;
  };

export const getGetDebugFakeCitizenUrl = () => {
  return `http://localhost:8080/debug/fake/citizen`;
};

export const getDebugFakeCitizen = async (
  options?: RequestInit,
): Promise<getDebugFakeCitizenResponse> => {
  const res = await fetch(getGetDebugFakeCitizenUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getDebugFakeCitizenResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDebugFakeCitizenResponse;
};

export type getDebugFakeCitizensResponse200 = {
  data: FullCitizen[];
  status: 200;
};

export type getDebugFakeCitizensResponseComposite =
  getDebugFakeCitizensResponse200;

export type getDebugFakeCitizensResponse =
  getDebugFakeCitizensResponseComposite & {
    headers: Headers;
  };

export const getGetDebugFakeCitizensUrl = (
  params?: GetDebugFakeCitizensParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8080/debug/fake/citizens?${stringifiedParams}`
    : `http://localhost:8080/debug/fake/citizens`;
};

export const getDebugFakeCitizens = async (
  params?: GetDebugFakeCitizensParams,
  options?: RequestInit,
): Promise<getDebugFakeCitizensResponse> => {
  const res = await fetch(getGetDebugFakeCitizensUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getDebugFakeCitizensResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDebugFakeCitizensResponse;
};

export type postDebugJWTResponse200 = {
  data: ValueTupleAuthResponse;
  status: 200;
};

export type postDebugJWTResponseComposite = postDebugJWTResponse200;

export type postDebugJWTResponse = postDebugJWTResponseComposite & {
  headers: Headers;
};

export const getPostDebugJWTUrl = () => {
  return `http://localhost:8080/debug/JWT`;
};

export const postDebugJWT = async (
  role: Role[],
  options?: RequestInit,
): Promise<postDebugJWTResponse> => {
  const res = await fetch(getPostDebugJWTUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(role),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postDebugJWTResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postDebugJWTResponse;
};

export type postDebugPlaygroundResponse200 = {
  data: void;
  status: 200;
};

export type postDebugPlaygroundResponseComposite =
  postDebugPlaygroundResponse200;

export type postDebugPlaygroundResponse =
  postDebugPlaygroundResponseComposite & {
    headers: Headers;
  };

export const getPostDebugPlaygroundUrl = () => {
  return `http://localhost:8080/debug/Playground`;
};

export const postDebugPlayground = async (
  options?: RequestInit,
): Promise<postDebugPlaygroundResponse> => {
  const res = await fetch(getPostDebugPlaygroundUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postDebugPlaygroundResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postDebugPlaygroundResponse;
};

export type postDebugCreateCitizenResponse200 = {
  data: CitizenCreationResult;
  status: 200;
};

export type postDebugCreateCitizenResponseComposite =
  postDebugCreateCitizenResponse200;

export type postDebugCreateCitizenResponse =
  postDebugCreateCitizenResponseComposite & {
    headers: Headers;
  };

export const getPostDebugCreateCitizenUrl = () => {
  return `http://localhost:8080/debug/create_citizen`;
};

export const postDebugCreateCitizen = async (
  options?: RequestInit,
): Promise<postDebugCreateCitizenResponse> => {
  const res = await fetch(getPostDebugCreateCitizenUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postDebugCreateCitizenResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postDebugCreateCitizenResponse;
};

export type getDepartmentsResponse200 = {
  data: Department[];
  status: 200;
};

export type getDepartmentsResponseComposite = getDepartmentsResponse200;

export type getDepartmentsResponse = getDepartmentsResponseComposite & {
  headers: Headers;
};

export const getGetDepartmentsUrl = () => {
  return `http://localhost:8080/departments`;
};

export const getDepartments = async (
  options?: RequestInit,
): Promise<getDepartmentsResponse> => {
  const res = await fetch(getGetDepartmentsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getDepartmentsResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDepartmentsResponse;
};

export type postDepartmentsResponse200 = {
  data: Department[];
  status: 200;
};

export type postDepartmentsResponseComposite = postDepartmentsResponse200;

export type postDepartmentsResponse = postDepartmentsResponseComposite & {
  headers: Headers;
};

export const getPostDepartmentsUrl = () => {
  return `http://localhost:8080/departments`;
};

export const postDepartments = async (
  options?: RequestInit,
): Promise<postDepartmentsResponse> => {
  const res = await fetch(getPostDepartmentsUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postDepartmentsResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postDepartmentsResponse;
};

export type getElectionsResponse200 = {
  data: ElectionListModel;
  status: 200;
};

export type getElectionsResponseComposite = getElectionsResponse200;

export type getElectionsResponse = getElectionsResponseComposite & {
  headers: Headers;
};

export const getGetElectionsUrl = (params?: GetElectionsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8080/elections?${stringifiedParams}`
    : `http://localhost:8080/elections`;
};

export const getElections = async (
  params?: GetElectionsParams,
  options?: RequestInit,
): Promise<getElectionsResponse> => {
  const res = await fetch(getGetElectionsUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getElectionsResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getElectionsResponse;
};

/**
 * @summary  (Secured - Roles: BoardPresident)
 */
export type postTableCitizenIdAuthorizeResponse200 = {
  data: BooleanReturn;
  status: 200;
};

export type postTableCitizenIdAuthorizeResponseComposite =
  postTableCitizenIdAuthorizeResponse200;

export type postTableCitizenIdAuthorizeResponse =
  postTableCitizenIdAuthorizeResponseComposite & {
    headers: Headers;
  };

export const getPostTableCitizenIdAuthorizeUrl = (
  citizenId: string,
  params?: PostTableCitizenIdAuthorizeParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:8080/table/${citizenId}/authorize?${stringifiedParams}`
    : `http://localhost:8080/table/${citizenId}/authorize`;
};

export const postTableCitizenIdAuthorize = async (
  citizenId: string,
  params?: PostTableCitizenIdAuthorizeParams,
  options?: RequestInit,
): Promise<postTableCitizenIdAuthorizeResponse> => {
  const res = await fetch(
    getPostTableCitizenIdAuthorizeUrl(citizenId, params),
    {
      ...options,
      method: "POST",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postTableCitizenIdAuthorizeResponse["data"] = body
    ? JSON.parse(body)
    : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postTableCitizenIdAuthorizeResponse;
};

/**
 * @summary  (Secured - Roles: BoardPresident)
 */
export type putTableCloseResponse200 = {
  data: BooleanReturn;
  status: 200;
};

export type putTableCloseResponseComposite = putTableCloseResponse200;

export type putTableCloseResponse = putTableCloseResponseComposite & {
  headers: Headers;
};

export const getPutTableCloseUrl = () => {
  return `http://localhost:8080/table/close`;
};

export const putTableClose = async (
  options?: RequestInit,
): Promise<putTableCloseResponse> => {
  const res = await fetch(getPutTableCloseUrl(), {
    ...options,
    method: "PUT",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: putTableCloseResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as putTableCloseResponse;
};

/**
 * @summary  (Secured - Roles: BoardPresident)
 */
export type putTableOpenResponse200 = {
  data: BooleanReturn;
  status: 200;
};

export type putTableOpenResponseComposite = putTableOpenResponse200;

export type putTableOpenResponse = putTableOpenResponseComposite & {
  headers: Headers;
};

export const getPutTableOpenUrl = () => {
  return `http://localhost:8080/table/open`;
};

export const putTableOpen = async (
  options?: RequestInit,
): Promise<putTableOpenResponse> => {
  const res = await fetch(getPutTableOpenUrl(), {
    ...options,
    method: "PUT",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: putTableOpenResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as putTableOpenResponse;
};
